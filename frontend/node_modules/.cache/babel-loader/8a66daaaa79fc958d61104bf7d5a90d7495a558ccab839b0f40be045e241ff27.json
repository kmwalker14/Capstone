{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport { Mark, mergeAttributes } from '@tiptap/core';\nconst mergeNestedSpanStyles = element => {\n  if (!element.children.length) {\n    return;\n  }\n  const childSpans = element.querySelectorAll('span');\n  if (!childSpans) {\n    return;\n  }\n  childSpans.forEach(childSpan => {\n    var _a, _b;\n    const childStyle = childSpan.getAttribute('style');\n    const closestParentSpanStyleOfChild = (_b = (_a = childSpan.parentElement) === null || _a === void 0 ? void 0 : _a.closest('span')) === null || _b === void 0 ? void 0 : _b.getAttribute('style');\n    childSpan.setAttribute('style', `${closestParentSpanStyleOfChild};${childStyle}`);\n  });\n};\n/**\n * This extension allows you to create text styles. It is required by default\n * for the `textColor` and `backgroundColor` extensions.\n * @see https://www.tiptap.dev/api/marks/text-style\n */\nconst TextStyle = Mark.create({\n  name: 'textStyle',\n  priority: 101,\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      mergeNestedSpanStyles: false\n    };\n  },\n  parseHTML() {\n    return [{\n      tag: 'span',\n      getAttrs: element => {\n        const hasStyles = element.hasAttribute('style');\n        if (!hasStyles) {\n          return false;\n        }\n        if (this.options.mergeNestedSpanStyles) {\n          mergeNestedSpanStyles(element);\n        }\n        return {};\n      }\n    }];\n  },\n  renderHTML({\n    HTMLAttributes\n  }) {\n    return ['span', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      removeEmptyTextStyle: () => ({\n        tr\n      }) => {\n        const {\n          selection\n        } = tr;\n        // Gather all of the nodes within the selection range.\n        // We would need to go through each node individually\n        // to check if it has any inline style attributes.\n        // Otherwise, calling commands.unsetMark(this.name)\n        // removes everything from all the nodes\n        // within the selection range.\n        tr.doc.nodesBetween(selection.from, selection.to, (node, pos) => {\n          // Check if it's a paragraph element, if so, skip this node as we apply\n          // the text style to inline text nodes only (span).\n          if (node.isTextblock) {\n            return true;\n          }\n          // Check if the node has no inline style attributes.\n          // Filter out non-`textStyle` marks.\n          if (!node.marks.filter(mark => mark.type === this.type).some(mark => Object.values(mark.attrs).some(value => !!value))) {\n            // Proceed with the removal of the `textStyle` mark for this node only\n            tr.removeMark(pos, pos + node.nodeSize, this.type);\n          }\n        });\n        return true;\n      }\n    };\n  }\n});\nexport { TextStyle, TextStyle as default };","map":{"version":3,"names":["mergeNestedSpanStyles","element","children","length","childSpans","querySelectorAll","forEach","childSpan","childStyle","getAttribute","closestParentSpanStyleOfChild","_b","_a","parentElement","closest","setAttribute","TextStyle","Mark","create","name","priority","addOptions","HTMLAttributes","parseHTML","tag","getAttrs","hasStyles","hasAttribute","options","renderHTML","mergeAttributes","addCommands","removeEmptyTextStyle","tr","selection","doc","nodesBetween","from","to","node","pos","isTextblock","marks","filter","mark","type","some","Object","values","attrs","value","removeMark","nodeSize"],"sources":["../src/text-style.ts"],"sourcesContent":["import {\n  Mark,\n  mergeAttributes,\n} from '@tiptap/core'\n\nexport interface TextStyleOptions {\n  /**\n   * HTML attributes to add to the span element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>,\n  /**\n   * When enabled, merges the styles of nested spans into the child span during HTML parsing.\n   * This prioritizes the style of the child span.\n   * Used when parsing content created in other editors.\n   * (Fix for ProseMirror's default behavior.)\n   * @default false\n   */\n  mergeNestedSpanStyles: boolean,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    textStyle: {\n      /**\n       * Remove spans without inline style attributes.\n       * @example editor.commands.removeEmptyTextStyle()\n       */\n      removeEmptyTextStyle: () => ReturnType,\n    }\n  }\n}\n\nconst mergeNestedSpanStyles = (element: HTMLElement) => {\n  if (!element.children.length) { return }\n  const childSpans = element.querySelectorAll('span')\n\n  if (!childSpans) { return }\n\n  childSpans.forEach(childSpan => {\n    const childStyle = childSpan.getAttribute('style')\n    const closestParentSpanStyleOfChild = childSpan.parentElement?.closest('span')?.getAttribute('style')\n\n    childSpan.setAttribute('style', `${closestParentSpanStyleOfChild};${childStyle}`)\n\n  })\n}\n\n/**\n * This extension allows you to create text styles. It is required by default\n * for the `textColor` and `backgroundColor` extensions.\n * @see https://www.tiptap.dev/api/marks/text-style\n */\nexport const TextStyle = Mark.create<TextStyleOptions>({\n  name: 'textStyle',\n\n  priority: 101,\n\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      mergeNestedSpanStyles: false,\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'span',\n        getAttrs: element => {\n          const hasStyles = (element as HTMLElement).hasAttribute('style')\n\n          if (!hasStyles) {\n            return false\n          }\n          if (this.options.mergeNestedSpanStyles) { mergeNestedSpanStyles(element) }\n\n          return {}\n        },\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return ['span', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      removeEmptyTextStyle: () => ({ tr }) => {\n\n        const { selection } = tr\n\n        // Gather all of the nodes within the selection range.\n        // We would need to go through each node individually\n        // to check if it has any inline style attributes.\n        // Otherwise, calling commands.unsetMark(this.name)\n        // removes everything from all the nodes\n        // within the selection range.\n        tr.doc.nodesBetween(selection.from, selection.to, (node, pos) => {\n\n          // Check if it's a paragraph element, if so, skip this node as we apply\n          // the text style to inline text nodes only (span).\n          if (node.isTextblock) {\n            return true\n          }\n\n          // Check if the node has no inline style attributes.\n          // Filter out non-`textStyle` marks.\n          if (\n            !node.marks.filter(mark => mark.type === this.type).some(mark => Object.values(mark.attrs).some(value => !!value))) {\n            // Proceed with the removal of the `textStyle` mark for this node only\n            tr.removeMark(pos, pos + node.nodeSize, this.type)\n          }\n        })\n\n        return true\n      },\n    }\n  },\n\n})\n"],"mappings":";;;;;AAkCA,MAAMA,qBAAqB,GAAIC,OAAoB,IAAI;EACrD,IAAI,CAACA,OAAO,CAACC,QAAQ,CAACC,MAAM,EAAE;IAAE;;EAChC,MAAMC,UAAU,GAAGH,OAAO,CAACI,gBAAgB,CAAC,MAAM,CAAC;EAEnD,IAAI,CAACD,UAAU,EAAE;IAAE;;EAEnBA,UAAU,CAACE,OAAO,CAACC,SAAS,IAAG;;IAC7B,MAAMC,UAAU,GAAGD,SAAS,CAACE,YAAY,CAAC,OAAO,CAAC;IAClD,MAAMC,6BAA6B,GAAG,CAAAC,EAAA,IAAAC,EAAA,GAAAL,SAAS,CAACM,aAAa,cAAAD,EAAA,uBAAAA,EAAA,CAAEE,OAAO,CAAC,MAAM,CAAC,cAAAH,EAAA,uBAAAA,EAAA,CAAEF,YAAY,CAAC,OAAO,CAAC;IAErGF,SAAS,CAACQ,YAAY,CAAC,OAAO,EAAE,GAAGL,6BAA6B,IAAIF,UAAU,EAAE,CAAC;EAEnF,CAAC,CAAC;AACJ,CAAC;AAED;;;;AAIG;AACU,MAAAQ,SAAS,GAAGC,IAAI,CAACC,MAAM,CAAmB;EACrDC,IAAI,EAAE,WAAW;EAEjBC,QAAQ,EAAE,GAAG;EAEbC,UAAUA,CAAA;IACR,OAAO;MACLC,cAAc,EAAE,EAAE;MAClBtB,qBAAqB,EAAE;KACxB;GACF;EAEDuB,SAASA,CAAA;IACP,OAAO,CACL;MACEC,GAAG,EAAE,MAAM;MACXC,QAAQ,EAAExB,OAAO,IAAG;QAClB,MAAMyB,SAAS,GAAIzB,OAAuB,CAAC0B,YAAY,CAAC,OAAO,CAAC;QAEhE,IAAI,CAACD,SAAS,EAAE;UACd,OAAO,KAAK;;QAEd,IAAI,IAAI,CAACE,OAAO,CAAC5B,qBAAqB,EAAE;UAAEA,qBAAqB,CAACC,OAAO,CAAC;;QAExE,OAAO,EAAE;;IAEZ,EACF;GACF;EAED4B,UAAUA,CAAC;IAAEP;EAAc,CAAE;IAC3B,OAAO,CAAC,MAAM,EAAEQ,eAAe,CAAC,IAAI,CAACF,OAAO,CAACN,cAAc,EAAEA,cAAc,CAAC,EAAE,CAAC,CAAC;GACjF;EAEDS,WAAWA,CAAA;IACT,OAAO;MACLC,oBAAoB,EAAEA,CAAA,KAAM,CAAC;QAAEC;MAAE,CAAE,KAAI;QAErC,MAAM;UAAEC;QAAS,CAAE,GAAGD,EAAE;;;;;;;QAQxBA,EAAE,CAACE,GAAG,CAACC,YAAY,CAACF,SAAS,CAACG,IAAI,EAAEH,SAAS,CAACI,EAAE,EAAE,CAACC,IAAI,EAAEC,GAAG,KAAI;;;UAI9D,IAAID,IAAI,CAACE,WAAW,EAAE;YACpB,OAAO,IAAI;;;;UAKb,IACE,CAACF,IAAI,CAACG,KAAK,CAACC,MAAM,CAACC,IAAI,IAAIA,IAAI,CAACC,IAAI,KAAK,IAAI,CAACA,IAAI,CAAC,CAACC,IAAI,CAACF,IAAI,IAAIG,MAAM,CAACC,MAAM,CAACJ,IAAI,CAACK,KAAK,CAAC,CAACH,IAAI,CAACI,KAAK,IAAI,CAAC,CAACA,KAAK,CAAC,CAAC,EAAE;;YAEpHjB,EAAE,CAACkB,UAAU,CAACX,GAAG,EAAEA,GAAG,GAAGD,IAAI,CAACa,QAAQ,EAAE,IAAI,CAACP,IAAI,CAAC;;QAEtD,CAAC,CAAC;QAEF,OAAO,IAAI;;KAEd;;AAGJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}