{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport { combineTransactionSteps, getChangedRanges, findChildrenInRange, getMarksBetween, getAttributes, Mark, mergeAttributes, markPasteRule } from '@tiptap/core';\nimport { tokenize, find, registerCustomProtocol, reset } from 'linkifyjs';\nimport { Plugin, PluginKey } from '@tiptap/pm/state';\n\n/**\n * Check if the provided tokens form a valid link structure, which can either be a single link token\n * or a link token surrounded by parentheses or square brackets.\n *\n * This ensures that only complete and valid text is hyperlinked, preventing cases where a valid\n * top-level domain (TLD) is immediately followed by an invalid character, like a number. For\n * example, with the `find` method from Linkify, entering `example.com1` would result in\n * `example.com` being linked and the trailing `1` left as plain text. By using the `tokenize`\n * method, we can perform more comprehensive validation on the input text.\n */\nfunction isValidLinkStructure(tokens) {\n  if (tokens.length === 1) {\n    return tokens[0].isLink;\n  }\n  if (tokens.length === 3 && tokens[1].isLink) {\n    return ['()', '[]'].includes(tokens[0].value + tokens[2].value);\n  }\n  return false;\n}\n/**\n * This plugin allows you to automatically add links to your editor.\n * @param options The plugin options\n * @returns The plugin instance\n */\nfunction autolink(options) {\n  return new Plugin({\n    key: new PluginKey('autolink'),\n    appendTransaction: (transactions, oldState, newState) => {\n      /**\n       * Does the transaction change the document?\n       */\n      const docChanges = transactions.some(transaction => transaction.docChanged) && !oldState.doc.eq(newState.doc);\n      /**\n       * Prevent autolink if the transaction is not a document change or if the transaction has the meta `preventAutolink`.\n       */\n      const preventAutolink = transactions.some(transaction => transaction.getMeta('preventAutolink'));\n      /**\n       * Prevent autolink if the transaction is not a document change\n       * or if the transaction has the meta `preventAutolink`.\n       */\n      if (!docChanges || preventAutolink) {\n        return;\n      }\n      const {\n        tr\n      } = newState;\n      const transform = combineTransactionSteps(oldState.doc, [...transactions]);\n      const changes = getChangedRanges(transform);\n      changes.forEach(({\n        newRange\n      }) => {\n        // Now letâ€™s see if we can add new links.\n        const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, node => node.isTextblock);\n        let textBlock;\n        let textBeforeWhitespace;\n        if (nodesInChangedRanges.length > 1) {\n          // Grab the first node within the changed ranges (ex. the first of two paragraphs when hitting enter).\n          textBlock = nodesInChangedRanges[0];\n          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, undefined, ' ');\n        } else if (nodesInChangedRanges.length\n        // We want to make sure to include the block seperator argument to treat hard breaks like spaces.\n        && newState.doc.textBetween(newRange.from, newRange.to, ' ', ' ').endsWith(' ')) {\n          textBlock = nodesInChangedRanges[0];\n          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, undefined, ' ');\n        }\n        if (textBlock && textBeforeWhitespace) {\n          const wordsBeforeWhitespace = textBeforeWhitespace.split(' ').filter(s => s !== '');\n          if (wordsBeforeWhitespace.length <= 0) {\n            return false;\n          }\n          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];\n          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);\n          if (!lastWordBeforeSpace) {\n            return false;\n          }\n          const linksBeforeSpace = tokenize(lastWordBeforeSpace).map(t => t.toObject(options.defaultProtocol));\n          if (!isValidLinkStructure(linksBeforeSpace)) {\n            return false;\n          }\n          linksBeforeSpace.filter(link => link.isLink)\n          // Calculate link position.\n          .map(link => ({\n            ...link,\n            from: lastWordAndBlockOffset + link.start + 1,\n            to: lastWordAndBlockOffset + link.end + 1\n          }))\n          // ignore link inside code mark\n          .filter(link => {\n            if (!newState.schema.marks.code) {\n              return true;\n            }\n            return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);\n          })\n          // validate link\n          .filter(link => options.validate(link.value))\n          // check whether should autolink\n          .filter(link => options.shouldAutoLink(link.value))\n          // Add link mark.\n          .forEach(link => {\n            if (getMarksBetween(link.from, link.to, newState.doc).some(item => item.mark.type === options.type)) {\n              return;\n            }\n            tr.addMark(link.from, link.to, options.type.create({\n              href: link.href\n            }));\n          });\n        }\n      });\n      if (!tr.steps.length) {\n        return;\n      }\n      return tr;\n    }\n  });\n}\nfunction clickHandler(options) {\n  return new Plugin({\n    key: new PluginKey('handleClickLink'),\n    props: {\n      handleClick: (view, pos, event) => {\n        var _a, _b;\n        if (event.button !== 0) {\n          return false;\n        }\n        if (!view.editable) {\n          return false;\n        }\n        let a = event.target;\n        const els = [];\n        while (a.nodeName !== 'DIV') {\n          els.push(a);\n          a = a.parentNode;\n        }\n        if (!els.find(value => value.nodeName === 'A')) {\n          return false;\n        }\n        const attrs = getAttributes(view.state, options.type.name);\n        const link = event.target;\n        const href = (_a = link === null || link === void 0 ? void 0 : link.href) !== null && _a !== void 0 ? _a : attrs.href;\n        const target = (_b = link === null || link === void 0 ? void 0 : link.target) !== null && _b !== void 0 ? _b : attrs.target;\n        if (link && href) {\n          window.open(href, target);\n          return true;\n        }\n        return false;\n      }\n    }\n  });\n}\nfunction pasteHandler(options) {\n  return new Plugin({\n    key: new PluginKey('handlePasteLink'),\n    props: {\n      handlePaste: (view, event, slice) => {\n        const {\n          state\n        } = view;\n        const {\n          selection\n        } = state;\n        const {\n          empty\n        } = selection;\n        if (empty) {\n          return false;\n        }\n        let textContent = '';\n        slice.content.forEach(node => {\n          textContent += node.textContent;\n        });\n        const link = find(textContent, {\n          defaultProtocol: options.defaultProtocol\n        }).find(item => item.isLink && item.value === textContent);\n        if (!textContent || !link) {\n          return false;\n        }\n        return options.editor.commands.setMark(options.type, {\n          href: link.href\n        });\n      }\n    }\n  });\n}\nconst pasteRegex = /https?:\\/\\/(?:www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z]{2,}\\b(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)/gi;\n// From DOMPurify\n// https://github.com/cure53/DOMPurify/blob/main/src/regexp.js\n// eslint-disable-next-line no-control-regex\nconst ATTR_WHITESPACE = /[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g;\nfunction isAllowedUri(uri, protocols) {\n  const allowedProtocols = ['http', 'https', 'ftp', 'ftps', 'mailto', 'tel', 'callto', 'sms', 'cid', 'xmpp'];\n  if (protocols) {\n    protocols.forEach(protocol => {\n      const nextProtocol = typeof protocol === 'string' ? protocol : protocol.scheme;\n      if (nextProtocol) {\n        allowedProtocols.push(nextProtocol);\n      }\n    });\n  }\n  return !uri || uri.replace(ATTR_WHITESPACE, '').match(new RegExp(\n  // eslint-disable-next-line no-useless-escape\n  `^(?:(?:${allowedProtocols.join('|')}):|[^a-z]|[a-z0-9+.\\-]+(?:[^a-z+.\\-:]|$))`, 'i'));\n}\n/**\n * This extension allows you to create links.\n * @see https://www.tiptap.dev/api/marks/link\n */\nconst Link = Mark.create({\n  name: 'link',\n  priority: 1000,\n  keepOnSplit: false,\n  exitable: true,\n  onCreate() {\n    if (this.options.validate && !this.options.shouldAutoLink) {\n      // Copy the validate function to the shouldAutoLink option\n      this.options.shouldAutoLink = this.options.validate;\n      console.warn('The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.');\n    }\n    this.options.protocols.forEach(protocol => {\n      if (typeof protocol === 'string') {\n        registerCustomProtocol(protocol);\n        return;\n      }\n      registerCustomProtocol(protocol.scheme, protocol.optionalSlashes);\n    });\n  },\n  onDestroy() {\n    reset();\n  },\n  inclusive() {\n    return this.options.autolink;\n  },\n  addOptions() {\n    return {\n      openOnClick: true,\n      linkOnPaste: true,\n      autolink: true,\n      protocols: [],\n      defaultProtocol: 'http',\n      HTMLAttributes: {\n        target: '_blank',\n        rel: 'noopener noreferrer nofollow',\n        class: null\n      },\n      isAllowedUri: (url, ctx) => !!isAllowedUri(url, ctx.protocols),\n      validate: url => !!url,\n      shouldAutoLink: url => !!url\n    };\n  },\n  addAttributes() {\n    return {\n      href: {\n        default: null,\n        parseHTML(element) {\n          return element.getAttribute('href');\n        }\n      },\n      target: {\n        default: this.options.HTMLAttributes.target\n      },\n      rel: {\n        default: this.options.HTMLAttributes.rel\n      },\n      class: {\n        default: this.options.HTMLAttributes.class\n      }\n    };\n  },\n  parseHTML() {\n    return [{\n      tag: 'a[href]',\n      getAttrs: dom => {\n        const href = dom.getAttribute('href');\n        // prevent XSS attacks\n        if (!href || !this.options.isAllowedUri(href, {\n          defaultValidate: url => !!isAllowedUri(url, this.options.protocols),\n          protocols: this.options.protocols,\n          defaultProtocol: this.options.defaultProtocol\n        })) {\n          return false;\n        }\n        return null;\n      }\n    }];\n  },\n  renderHTML({\n    HTMLAttributes\n  }) {\n    // prevent XSS attacks\n    if (!this.options.isAllowedUri(HTMLAttributes.href, {\n      defaultValidate: href => !!isAllowedUri(href, this.options.protocols),\n      protocols: this.options.protocols,\n      defaultProtocol: this.options.defaultProtocol\n    })) {\n      // strip out the href\n      return ['a', mergeAttributes(this.options.HTMLAttributes, {\n        ...HTMLAttributes,\n        href: ''\n      }), 0];\n    }\n    return ['a', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      setLink: attributes => ({\n        chain\n      }) => {\n        const {\n          href\n        } = attributes;\n        if (!this.options.isAllowedUri(href, {\n          defaultValidate: url => !!isAllowedUri(url, this.options.protocols),\n          protocols: this.options.protocols,\n          defaultProtocol: this.options.defaultProtocol\n        })) {\n          return false;\n        }\n        return chain().setMark(this.name, attributes).setMeta('preventAutolink', true).run();\n      },\n      toggleLink: attributes => ({\n        chain\n      }) => {\n        const {\n          href\n        } = attributes;\n        if (!this.options.isAllowedUri(href, {\n          defaultValidate: url => !!isAllowedUri(url, this.options.protocols),\n          protocols: this.options.protocols,\n          defaultProtocol: this.options.defaultProtocol\n        })) {\n          return false;\n        }\n        return chain().toggleMark(this.name, attributes, {\n          extendEmptyMarkRange: true\n        }).setMeta('preventAutolink', true).run();\n      },\n      unsetLink: () => ({\n        chain\n      }) => {\n        return chain().unsetMark(this.name, {\n          extendEmptyMarkRange: true\n        }).setMeta('preventAutolink', true).run();\n      }\n    };\n  },\n  addPasteRules() {\n    return [markPasteRule({\n      find: text => {\n        const foundLinks = [];\n        if (text) {\n          const {\n            protocols,\n            defaultProtocol\n          } = this.options;\n          const links = find(text).filter(item => item.isLink && this.options.isAllowedUri(item.value, {\n            defaultValidate: href => !!isAllowedUri(href, protocols),\n            protocols,\n            defaultProtocol\n          }));\n          if (links.length) {\n            links.forEach(link => foundLinks.push({\n              text: link.value,\n              data: {\n                href: link.href\n              },\n              index: link.start\n            }));\n          }\n        }\n        return foundLinks;\n      },\n      type: this.type,\n      getAttributes: match => {\n        var _a;\n        return {\n          href: (_a = match.data) === null || _a === void 0 ? void 0 : _a.href\n        };\n      }\n    })];\n  },\n  addProseMirrorPlugins() {\n    const plugins = [];\n    const {\n      protocols,\n      defaultProtocol\n    } = this.options;\n    if (this.options.autolink) {\n      plugins.push(autolink({\n        type: this.type,\n        defaultProtocol: this.options.defaultProtocol,\n        validate: url => this.options.isAllowedUri(url, {\n          defaultValidate: href => !!isAllowedUri(href, protocols),\n          protocols,\n          defaultProtocol\n        }),\n        shouldAutoLink: this.options.shouldAutoLink\n      }));\n    }\n    if (this.options.openOnClick === true) {\n      plugins.push(clickHandler({\n        type: this.type\n      }));\n    }\n    if (this.options.linkOnPaste) {\n      plugins.push(pasteHandler({\n        editor: this.editor,\n        defaultProtocol: this.options.defaultProtocol,\n        type: this.type\n      }));\n    }\n    return plugins;\n  }\n});\nexport { Link, Link as default, isAllowedUri, pasteRegex };","map":{"version":3,"names":["isValidLinkStructure","tokens","length","isLink","includes","value","autolink","options","Plugin","key","PluginKey","appendTransaction","transactions","oldState","newState","docChanges","some","transaction","docChanged","doc","eq","preventAutolink","getMeta","tr","transform","combineTransactionSteps","changes","getChangedRanges","forEach","newRange","nodesInChangedRanges","findChildrenInRange","node","isTextblock","textBlock","textBeforeWhitespace","textBetween","pos","nodeSize","undefined","from","to","endsWith","wordsBeforeWhitespace","split","filter","s","lastWordBeforeSpace","lastWordAndBlockOffset","lastIndexOf","linksBeforeSpace","tokenize","map","t","toObject","defaultProtocol","link","start","end","schema","marks","code","rangeHasMark","validate","shouldAutoLink","getMarksBetween","item","mark","type","addMark","create","href","steps","clickHandler","props","handleClick","view","event","button","editable","a","target","els","nodeName","push","parentNode","find","attrs","getAttributes","state","name","_a","_b","window","open","pasteHandler","handlePaste","slice","selection","empty","textContent","content","editor","commands","setMark","pasteRegex","ATTR_WHITESPACE","isAllowedUri","uri","protocols","allowedProtocols","protocol","nextProtocol","scheme","replace","match","RegExp","join","Link","Mark","priority","keepOnSplit","exitable","onCreate","console","warn","registerCustomProtocol","optionalSlashes","onDestroy","reset","inclusive","addOptions","openOnClick","linkOnPaste","HTMLAttributes","rel","class","url","ctx","addAttributes","default","parseHTML","element","getAttribute","tag","getAttrs","dom","defaultValidate","renderHTML","mergeAttributes","addCommands","setLink","attributes","chain","setMeta","run","toggleLink","toggleMark","extendEmptyMarkRange","unsetLink","unsetMark","addPasteRules","markPasteRule","text","foundLinks","links","data","index","addProseMirrorPlugins","plugins"],"sources":["../src/helpers/autolink.ts","../src/helpers/clickHandler.ts","../src/helpers/pasteHandler.ts","../src/link.ts"],"sourcesContent":["import {\n  combineTransactionSteps,\n  findChildrenInRange,\n  getChangedRanges,\n  getMarksBetween,\n  NodeWithPos,\n} from '@tiptap/core'\nimport { MarkType } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport { MultiToken, tokenize } from 'linkifyjs'\n\n/**\n * Check if the provided tokens form a valid link structure, which can either be a single link token\n * or a link token surrounded by parentheses or square brackets.\n *\n * This ensures that only complete and valid text is hyperlinked, preventing cases where a valid\n * top-level domain (TLD) is immediately followed by an invalid character, like a number. For\n * example, with the `find` method from Linkify, entering `example.com1` would result in\n * `example.com` being linked and the trailing `1` left as plain text. By using the `tokenize`\n * method, we can perform more comprehensive validation on the input text.\n */\nfunction isValidLinkStructure(tokens: Array<ReturnType<MultiToken['toObject']>>) {\n  if (tokens.length === 1) {\n    return tokens[0].isLink\n  }\n\n  if (tokens.length === 3 && tokens[1].isLink) {\n    return ['()', '[]'].includes(tokens[0].value + tokens[2].value)\n  }\n\n  return false\n}\n\ntype AutolinkOptions = {\n  type: MarkType\n  defaultProtocol: string\n  validate: (url: string) => boolean\n  shouldAutoLink: (url: string) => boolean\n}\n\n/**\n * This plugin allows you to automatically add links to your editor.\n * @param options The plugin options\n * @returns The plugin instance\n */\nexport function autolink(options: AutolinkOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('autolink'),\n    appendTransaction: (transactions, oldState, newState) => {\n      /**\n       * Does the transaction change the document?\n       */\n      const docChanges = transactions.some(transaction => transaction.docChanged) && !oldState.doc.eq(newState.doc)\n\n      /**\n       * Prevent autolink if the transaction is not a document change or if the transaction has the meta `preventAutolink`.\n       */\n      const preventAutolink = transactions.some(transaction => transaction.getMeta('preventAutolink'))\n\n      /**\n       * Prevent autolink if the transaction is not a document change\n       * or if the transaction has the meta `preventAutolink`.\n       */\n      if (!docChanges || preventAutolink) {\n        return\n      }\n\n      const { tr } = newState\n      const transform = combineTransactionSteps(oldState.doc, [...transactions])\n      const changes = getChangedRanges(transform)\n\n      changes.forEach(({ newRange }) => {\n        // Now letâ€™s see if we can add new links.\n        const nodesInChangedRanges = findChildrenInRange(\n          newState.doc,\n          newRange,\n          node => node.isTextblock,\n        )\n\n        let textBlock: NodeWithPos | undefined\n        let textBeforeWhitespace: string | undefined\n\n        if (nodesInChangedRanges.length > 1) {\n          // Grab the first node within the changed ranges (ex. the first of two paragraphs when hitting enter).\n          textBlock = nodesInChangedRanges[0]\n          textBeforeWhitespace = newState.doc.textBetween(\n            textBlock.pos,\n            textBlock.pos + textBlock.node.nodeSize,\n            undefined,\n            ' ',\n          )\n        } else if (\n          nodesInChangedRanges.length\n          // We want to make sure to include the block seperator argument to treat hard breaks like spaces.\n          && newState.doc.textBetween(newRange.from, newRange.to, ' ', ' ').endsWith(' ')\n        ) {\n          textBlock = nodesInChangedRanges[0]\n          textBeforeWhitespace = newState.doc.textBetween(\n            textBlock.pos,\n            newRange.to,\n            undefined,\n            ' ',\n          )\n        }\n\n        if (textBlock && textBeforeWhitespace) {\n          const wordsBeforeWhitespace = textBeforeWhitespace.split(' ').filter(s => s !== '')\n\n          if (wordsBeforeWhitespace.length <= 0) {\n            return false\n          }\n\n          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1]\n          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace)\n\n          if (!lastWordBeforeSpace) {\n            return false\n          }\n\n          const linksBeforeSpace = tokenize(lastWordBeforeSpace).map(t => t.toObject(options.defaultProtocol))\n\n          if (!isValidLinkStructure(linksBeforeSpace)) {\n            return false\n          }\n\n          linksBeforeSpace\n            .filter(link => link.isLink)\n            // Calculate link position.\n            .map(link => ({\n              ...link,\n              from: lastWordAndBlockOffset + link.start + 1,\n              to: lastWordAndBlockOffset + link.end + 1,\n            }))\n            // ignore link inside code mark\n            .filter(link => {\n              if (!newState.schema.marks.code) {\n                return true\n              }\n\n              return !newState.doc.rangeHasMark(\n                link.from,\n                link.to,\n                newState.schema.marks.code,\n              )\n            })\n            // validate link\n            .filter(link => options.validate(link.value))\n            // check whether should autolink\n            .filter(link => options.shouldAutoLink(link.value))\n            // Add link mark.\n            .forEach(link => {\n              if (getMarksBetween(link.from, link.to, newState.doc).some(item => item.mark.type === options.type)) {\n                return\n              }\n\n              tr.addMark(\n                link.from,\n                link.to,\n                options.type.create({\n                  href: link.href,\n                }),\n              )\n            })\n        }\n      })\n\n      if (!tr.steps.length) {\n        return\n      }\n\n      return tr\n    },\n  })\n}\n","import { getAttributes } from '@tiptap/core'\nimport { MarkType } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\n\ntype ClickHandlerOptions = {\n  type: MarkType;\n}\n\nexport function clickHandler(options: ClickHandlerOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('handleClickLink'),\n    props: {\n      handleClick: (view, pos, event) => {\n        if (event.button !== 0) {\n          return false\n        }\n\n        if (!view.editable) {\n          return false\n        }\n\n        let a = event.target as HTMLElement\n        const els = []\n\n        while (a.nodeName !== 'DIV') {\n          els.push(a)\n          a = a.parentNode as HTMLElement\n        }\n\n        if (!els.find(value => value.nodeName === 'A')) {\n          return false\n        }\n\n        const attrs = getAttributes(view.state, options.type.name)\n        const link = (event.target as HTMLAnchorElement)\n\n        const href = link?.href ?? attrs.href\n        const target = link?.target ?? attrs.target\n\n        if (link && href) {\n          window.open(href, target)\n\n          return true\n        }\n\n        return false\n      },\n    },\n  })\n}\n","import { Editor } from '@tiptap/core'\nimport { MarkType } from '@tiptap/pm/model'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport { find } from 'linkifyjs'\n\ntype PasteHandlerOptions = {\n  editor: Editor\n  defaultProtocol: string\n  type: MarkType\n}\n\nexport function pasteHandler(options: PasteHandlerOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('handlePasteLink'),\n    props: {\n      handlePaste: (view, event, slice) => {\n        const { state } = view\n        const { selection } = state\n        const { empty } = selection\n\n        if (empty) {\n          return false\n        }\n\n        let textContent = ''\n\n        slice.content.forEach(node => {\n          textContent += node.textContent\n        })\n\n        const link = find(textContent, { defaultProtocol: options.defaultProtocol }).find(item => item.isLink && item.value === textContent)\n\n        if (!textContent || !link) {\n          return false\n        }\n\n        return options.editor.commands.setMark(options.type, {\n          href: link.href,\n        })\n      },\n    },\n  })\n}\n","import {\n  Mark, markPasteRule, mergeAttributes, PasteRuleMatch,\n} from '@tiptap/core'\nimport { Plugin } from '@tiptap/pm/state'\nimport { find, registerCustomProtocol, reset } from 'linkifyjs'\n\nimport { autolink } from './helpers/autolink.js'\nimport { clickHandler } from './helpers/clickHandler.js'\nimport { pasteHandler } from './helpers/pasteHandler.js'\n\nexport interface LinkProtocolOptions {\n  /**\n   * The protocol scheme to be registered.\n   * @default '''\n   * @example 'ftp'\n   * @example 'git'\n   */\n  scheme: string;\n\n  /**\n   * If enabled, it allows optional slashes after the protocol.\n   * @default false\n   * @example true\n   */\n  optionalSlashes?: boolean;\n}\n\nexport const pasteRegex = /https?:\\/\\/(?:www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z]{2,}\\b(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)/gi\n\n/**\n * @deprecated The default behavior is now to open links when the editor is not editable.\n */\ntype DeprecatedOpenWhenNotEditable = 'whenNotEditable';\n\nexport interface LinkOptions {\n  /**\n   * If enabled, the extension will automatically add links as you type.\n   * @default true\n   * @example false\n   */\n  autolink: boolean;\n\n  /**\n   * An array of custom protocols to be registered with linkifyjs.\n   * @default []\n   * @example ['ftp', 'git']\n   */\n  protocols: Array<LinkProtocolOptions | string>;\n\n  /**\n   * Default protocol to use when no protocol is specified.\n   * @default 'http'\n   */\n  defaultProtocol: string;\n  /**\n   * If enabled, links will be opened on click.\n   * @default true\n   * @example false\n   */\n  openOnClick: boolean | DeprecatedOpenWhenNotEditable;\n  /**\n   * Adds a link to the current selection if the pasted content only contains an url.\n   * @default true\n   * @example false\n   */\n  linkOnPaste: boolean;\n\n  /**\n   * HTML attributes to add to the link element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>;\n\n  /**\n   * @deprecated Use the `shouldAutoLink` option instead.\n   * A validation function that modifies link verification for the auto linker.\n   * @param url - The url to be validated.\n   * @returns - True if the url is valid, false otherwise.\n   */\n  validate: (url: string) => boolean;\n\n  /**\n   * A validation function which is used for configuring link verification for preventing XSS attacks.\n   * Only modify this if you know what you're doing.\n   *\n   * @returns {boolean} `true` if the URL is valid, `false` otherwise.\n   *\n   * @example\n   * isAllowedUri: (url, { defaultValidate, protocols, defaultProtocol }) => {\n   * return url.startsWith('./') || defaultValidate(url)\n   * }\n   */\n  isAllowedUri: (\n    /**\n     * The URL to be validated.\n     */\n    url: string,\n    ctx: {\n      /**\n       * The default validation function.\n       */\n      defaultValidate: (url: string) => boolean;\n      /**\n       * An array of allowed protocols for the URL (e.g., \"http\", \"https\"). As defined in the `protocols` option.\n       */\n      protocols: Array<LinkProtocolOptions | string>;\n      /**\n       * A string that represents the default protocol (e.g., 'http'). As defined in the `defaultProtocol` option.\n       */\n      defaultProtocol: string;\n    }\n  ) => boolean;\n\n  /**\n   * Determines whether a valid link should be automatically linked in the content.\n   *\n   * @param {string} url - The URL that has already been validated.\n   * @returns {boolean} - True if the link should be auto-linked; false if it should not be auto-linked.\n   */\n  shouldAutoLink: (url: string) => boolean;\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    link: {\n      /**\n       * Set a link mark\n       * @param attributes The link attributes\n       * @example editor.commands.setLink({ href: 'https://tiptap.dev' })\n       */\n      setLink: (attributes: {\n        href: string;\n        target?: string | null;\n        rel?: string | null;\n        class?: string | null;\n      }) => ReturnType;\n      /**\n       * Toggle a link mark\n       * @param attributes The link attributes\n       * @example editor.commands.toggleLink({ href: 'https://tiptap.dev' })\n       */\n      toggleLink: (attributes: {\n        href: string;\n        target?: string | null;\n        rel?: string | null;\n        class?: string | null;\n      }) => ReturnType;\n      /**\n       * Unset a link mark\n       * @example editor.commands.unsetLink()\n       */\n      unsetLink: () => ReturnType;\n    };\n  }\n}\n\n// From DOMPurify\n// https://github.com/cure53/DOMPurify/blob/main/src/regexp.js\n// eslint-disable-next-line no-control-regex\nconst ATTR_WHITESPACE = /[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g\n\nexport function isAllowedUri(uri: string | undefined, protocols?: LinkOptions['protocols']) {\n  const allowedProtocols: string[] = [\n    'http',\n    'https',\n    'ftp',\n    'ftps',\n    'mailto',\n    'tel',\n    'callto',\n    'sms',\n    'cid',\n    'xmpp',\n  ]\n\n  if (protocols) {\n    protocols.forEach(protocol => {\n      const nextProtocol = typeof protocol === 'string' ? protocol : protocol.scheme\n\n      if (nextProtocol) {\n        allowedProtocols.push(nextProtocol)\n      }\n    })\n  }\n\n  return (\n    !uri\n    || uri\n      .replace(ATTR_WHITESPACE, '')\n      .match(\n        new RegExp(\n          // eslint-disable-next-line no-useless-escape\n          `^(?:(?:${allowedProtocols.join('|')}):|[^a-z]|[a-z0-9+.\\-]+(?:[^a-z+.\\-:]|$))`,\n          'i',\n        ),\n      )\n  )\n}\n\n/**\n * This extension allows you to create links.\n * @see https://www.tiptap.dev/api/marks/link\n */\nexport const Link = Mark.create<LinkOptions>({\n  name: 'link',\n\n  priority: 1000,\n\n  keepOnSplit: false,\n\n  exitable: true,\n\n  onCreate() {\n    if (this.options.validate && !this.options.shouldAutoLink) {\n      // Copy the validate function to the shouldAutoLink option\n      this.options.shouldAutoLink = this.options.validate\n      console.warn(\n        'The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.',\n      )\n    }\n    this.options.protocols.forEach(protocol => {\n      if (typeof protocol === 'string') {\n        registerCustomProtocol(protocol)\n        return\n      }\n      registerCustomProtocol(protocol.scheme, protocol.optionalSlashes)\n    })\n  },\n\n  onDestroy() {\n    reset()\n  },\n\n  inclusive() {\n    return this.options.autolink\n  },\n\n  addOptions() {\n    return {\n      openOnClick: true,\n      linkOnPaste: true,\n      autolink: true,\n      protocols: [],\n      defaultProtocol: 'http',\n      HTMLAttributes: {\n        target: '_blank',\n        rel: 'noopener noreferrer nofollow',\n        class: null,\n      },\n      isAllowedUri: (url, ctx) => !!isAllowedUri(url, ctx.protocols),\n      validate: url => !!url,\n      shouldAutoLink: url => !!url,\n    }\n  },\n\n  addAttributes() {\n    return {\n      href: {\n        default: null,\n        parseHTML(element) {\n          return element.getAttribute('href')\n        },\n      },\n      target: {\n        default: this.options.HTMLAttributes.target,\n      },\n      rel: {\n        default: this.options.HTMLAttributes.rel,\n      },\n      class: {\n        default: this.options.HTMLAttributes.class,\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'a[href]',\n        getAttrs: dom => {\n          const href = (dom as HTMLElement).getAttribute('href')\n\n          // prevent XSS attacks\n          if (\n            !href\n            || !this.options.isAllowedUri(href, {\n              defaultValidate: url => !!isAllowedUri(url, this.options.protocols),\n              protocols: this.options.protocols,\n              defaultProtocol: this.options.defaultProtocol,\n            })\n          ) {\n            return false\n          }\n          return null\n        },\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    // prevent XSS attacks\n    if (\n      !this.options.isAllowedUri(HTMLAttributes.href, {\n        defaultValidate: href => !!isAllowedUri(href, this.options.protocols),\n        protocols: this.options.protocols,\n        defaultProtocol: this.options.defaultProtocol,\n      })\n    ) {\n      // strip out the href\n      return [\n        'a',\n        mergeAttributes(this.options.HTMLAttributes, { ...HTMLAttributes, href: '' }),\n        0,\n      ]\n    }\n\n    return ['a', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0]\n  },\n\n  addCommands() {\n    return {\n      setLink:\n        attributes => ({ chain }) => {\n          const { href } = attributes\n\n          if (!this.options.isAllowedUri(href, {\n            defaultValidate: url => !!isAllowedUri(url, this.options.protocols),\n            protocols: this.options.protocols,\n            defaultProtocol: this.options.defaultProtocol,\n          })) {\n            return false\n          }\n\n          return chain().setMark(this.name, attributes).setMeta('preventAutolink', true).run()\n        },\n\n      toggleLink:\n        attributes => ({ chain }) => {\n          const { href } = attributes\n\n          if (!this.options.isAllowedUri(href, {\n            defaultValidate: url => !!isAllowedUri(url, this.options.protocols),\n            protocols: this.options.protocols,\n            defaultProtocol: this.options.defaultProtocol,\n          })) {\n            return false\n          }\n\n          return chain()\n            .toggleMark(this.name, attributes, { extendEmptyMarkRange: true })\n            .setMeta('preventAutolink', true)\n            .run()\n        },\n\n      unsetLink:\n        () => ({ chain }) => {\n          return chain()\n            .unsetMark(this.name, { extendEmptyMarkRange: true })\n            .setMeta('preventAutolink', true)\n            .run()\n        },\n    }\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: text => {\n          const foundLinks: PasteRuleMatch[] = []\n\n          if (text) {\n            const { protocols, defaultProtocol } = this.options\n            const links = find(text).filter(\n              item => item.isLink\n                && this.options.isAllowedUri(item.value, {\n                  defaultValidate: href => !!isAllowedUri(href, protocols),\n                  protocols,\n                  defaultProtocol,\n                }),\n            )\n\n            if (links.length) {\n              links.forEach(link => foundLinks.push({\n                text: link.value,\n                data: {\n                  href: link.href,\n                },\n                index: link.start,\n              }))\n            }\n          }\n\n          return foundLinks\n        },\n        type: this.type,\n        getAttributes: match => {\n          return {\n            href: match.data?.href,\n          }\n        },\n      }),\n    ]\n  },\n\n  addProseMirrorPlugins() {\n    const plugins: Plugin[] = []\n    const { protocols, defaultProtocol } = this.options\n\n    if (this.options.autolink) {\n      plugins.push(\n        autolink({\n          type: this.type,\n          defaultProtocol: this.options.defaultProtocol,\n          validate: url => this.options.isAllowedUri(url, {\n            defaultValidate: href => !!isAllowedUri(href, protocols),\n            protocols,\n            defaultProtocol,\n          }),\n          shouldAutoLink: this.options.shouldAutoLink,\n        }),\n      )\n    }\n\n    if (this.options.openOnClick === true) {\n      plugins.push(\n        clickHandler({\n          type: this.type,\n        }),\n      )\n    }\n\n    if (this.options.linkOnPaste) {\n      plugins.push(\n        pasteHandler({\n          editor: this.editor,\n          defaultProtocol: this.options.defaultProtocol,\n          type: this.type,\n        }),\n      )\n    }\n\n    return plugins\n  },\n})\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}